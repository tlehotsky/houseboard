<!doctype html><meta charset="utf-8"><title>HouseBoard – DayBuddy</title>
<!doctype html><meta charset="utf-8"><title>HouseBoard – DayBuddy</title>
<style>
/* ---- Base --------------------------------------------------------------- */
body{background:#0b0c10;color:#f2f5f9;font:400 16px/1.5 system-ui;margin:0}
.wrap h1{margin:0 0 2px 0}
/* Inset border around the entire viewport */
body::after{
  content:"";
  position:fixed;
  inset:8px;                 /* distance from the screen edge */
  border:1px solid rgba(255,255,255,.6); /* thin white border */
  border-radius:10px;        /* slight rounding; adjust if you prefer square corners */
  pointer-events:none;       /* don't block clicks */
  z-index:9999;              /* render above all content */
}
.wrap{padding:16px}
.legend{
  display:flex;
  gap:12px;
  margin:20px 0 24px;
  flex-wrap:wrap;
  justify-content:center;
}
.pill{
  display:inline-block;
  background: var(--c);
  color:#fff;
  border:1px solid rgba(255,255,255,.25);
  border-radius:999px;
  padding:6px 14px;
  font-weight:700;
  font-size:15px;
  letter-spacing:0.2px;
  box-shadow:0 2px 6px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25);
  transition:transform .1s ease, box-shadow .1s ease;
  text-shadow:0 1px 1px rgba(0,0,0,.4);
}
.pill:hover{
  transform:translateY(-1px);
  box-shadow:0 3px 10px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.3);
}
.badge{display:inline-flex;align-items:center;gap:8px}
.dot{width:10px;height:10px;border-radius:50%;display:inline-block;box-shadow:0 0 0 1px rgba(255,255,255,.08), inset 0 0 0 1px rgba(0,0,0,.6)}
/* color picker input styled like the old swatch */
.row input.clr{width:22px;height:22px;border-radius:50%;border:1px solid #2a3750;padding:0;background:none;appearance:none;-webkit-appearance:none;cursor:pointer}
.row input.clr::-webkit-color-swatch-wrapper{padding:0;border-radius:50%}
.row input.clr::-webkit-color-swatch{border:none;border-radius:50%}
/* ---- Grid --------------------------------------------------------------- */
.grid{
  display:grid;
  grid-template-columns:repeat(7,minmax(0,1fr));
  gap:6px;
  margin:0 20px; /* adds whitespace on both sides */
}
/* ---- Weather cards ----------------------------------------------------- */
.cards{
  display:grid;
  grid-template-columns:minmax(200px,20%) minmax(0,80%);
  gap:12px;
  margin:16px 20px 90px;
}
.card-row-schedules{
  grid-column:1 / -1;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:12px;
}
@media (max-width: 980px){
  .cards{ grid-template-columns: 1fr; }
}
.card{background:#1b1f29;border:1px solid #333;border-radius:10px;padding:12px;min-width:0}
.card h4{margin:0 0 4px 0;font-weight:700;opacity:.9}
# Tightened temperature card vertical spacing
/* Tightened temperature card vertical spacing */
.card h4{margin:0 0 4px 0;font-weight:700;opacity:.9}
.card .big{font-size:176px;font-weight:800;letter-spacing:0.5px;line-height:.85;margin:0}
.card .big .unit{ font-size:0.5em; margin-left:6px; opacity:.9; }
.card .muted{opacity:.75;font-size:14px;margin-top:4px}
#wxChart{width:100%;height:220px;display:block}
/* Weather legend */
#card-forecast #wxNote{display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin-top:6px}
.wx-key{display:inline-flex;align-items:center;gap:8px}
.wx-key .sw{display:inline-block;width:20px;height:0;border-top:3px solid currentColor}
.wx-key .temp{color:#ffd27d}
.wx-key .precip{color:#008ce0}
#card-slideshow img{border-radius:8px;display:block;width:100%;height:auto}
#card-slideshow .muted{margin-top:6px}


/* Rangers card positioning */
#card-rangers {
  position: relative;
  padding-bottom: 32px;
}

/* Highlight Rangers days broadcast on MSG */
.rangers-day.msg-day {
  background: #003b1f !important;  /* dark green */
  border-color: #1a6b43 !important;
}

#rangers-logo {
  position: absolute;
  bottom: 8px;
  left: 8px;      /* bottom-left corner */
  width: 42px;    /* adjust size here */
  height: auto;
  opacity: 0.9;
}

#devils-suck {
  position:absolute;
  bottom:8px;
  right:8px;
  font-size:26px;
  font-weight:900;
  color:#ff4a4a;
  text-shadow:0 0 6px rgba(0,0,0,0.7);
  opacity:0.95;
}

#rangers-sched {
  margin-top: 6px;
}
#rangers-grid{
  display:grid;
  grid-template-columns:repeat(7,minmax(0,1fr));
  gap:6px;
}
.rangers-day{
  background:#10131b;
  border:1px solid rgba(255,255,255,.15);
  border-radius:6px;
  padding:6px;
  min-height:80px;
  display:flex;
  flex-direction:column;
}
.rangers-day .day-label{
  font-size:13px;
  font-weight:600;
  opacity:.85;
  margin-bottom:4px;
}
.rangers-day .game{
  font-size:12px;
  line-height:1.35;
  opacity:.9;
}
.rangers-day .game + .game{
  margin-top:2px;
}
.rangers-day .nogame{
  font-size:12px;
  opacity:.55;
}





/* NFL schedule card as 7-day#card-slideshow #slide-bar{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;margin-top:6px}

/* NFL schedule card as 7-day row with auto-width tiles */
#card-nfl #nfl-sched{
  margin-top:6px;
}
#nfl-grid{
  display:flex;
  gap:6px;
  justify-content:flex-start;
}
.nfl-day{
  background:#10131b;
  border:1px solid rgba(255,255,255,.15);
  border-radius:6px;
  padding:6px;
  min-height:80px;
  display:flex;
  flex-direction:column;
  flex:0 0 auto;           /* width comes from content */
}
.nfl-day .day-label{
  font-size:13px;
  font-weight:600;
  opacity:.85;
  margin-bottom:4px;
}
.nfl-day .game{
  font-size:12px;
  line-height:1.35;
  opacity:.9;
}
.nfl-day .game + .game{
  margin-top:2px;
}
.nfl-day .nogame{
  font-size:12px;
  opacity:.55;
}

/* Slot-based time coloring (blue = morning, yellow = afternoon, red = evening) */
.nfl-day .game.morning{
  color:#7fb6ff;             /* soft blue text for morning games */
}
.nfl-day .game.afternoon{
  color:#ffe48a;             /* warm yellow text for afternoon games */
}
.nfl-day .game.evening{
  color:#ff9b9b;             /* light red text for evening games */
}
/* Force NFL broadcast tags (L, Y, P, O) to always be white */
.nfl-day .game b {
  color: #ffffff !important;
}


#card-slideshow #slide-bar .qr img{display:block;width:auto;height:auto;max-width:100px}
#card-slideshow #slide-bar .qr{ text-align:left; }
#card-slideshow #slide-bar .qr .muted{ text-align:left; }
#card-slideshow #slide-bar .meta-area{flex:1;display:flex;flex-direction:column;align-items:flex-end;gap:6px}
#card-slideshow #slide-bar .meta{ text-align:right; }
#card-slideshow{ justify-self:stretch; }
#card-slideshow img{ max-height: 40vh; }
/* #archive-photo-btn{background:#2a354a;color:#f2f5f9;border:1px solid #3b4765;border-radius:8px;padding:4px 10px;font-size:13px;font-weight:500;cursor:pointer;}
#archive-photo-btn:hover{background:#34415a;border-color:#4d5c7a;}

/* Bottom row: slideshow on the left, health cards stacked on the right */
.card-row-bottom{
  grid-column:1 / -1;
  display:grid;
  grid-template-columns:minmax(0,3fr) minmax(0,1fr);
  gap:12px;
  align-items:flex-start;
} */


#archive-photo-btn{background:#2a354a;color:#f2f5f9;border:1px solid #3b4765;border-radius:8px;padding:4px 10px;font-size:13px;font-weight:500;cursor:pointer;}
#archive-photo-btn:hover{background:#34415a;border-color:#4d5c7a;}

/* Network health card states */
#card-network {
  position: relative;
  overflow: hidden;
}

#card-network.good {
  border-color:#2ecc71;
  background:#014602;
  box-shadow:0 0 0 1px rgba(46,204,113,.35);

}

#card-network.warn {
  border-color:#f1c40f;
  background:#464a01;
  box-shadow:0 0 0 1px rgba(241,196,15,.35);
}

#card-network.bad {
  border-color:#e74c3c;
  background:#630602;
  box-shadow:0 0 0 1px rgba(231,76,60,.35);
}





#card-network.unknown {
  border-color:#555;
}

/* Tiny colored bullets next to text */
.net-pill-dot {
  display:inline-block;
  width: 16px;
  height:13px;
  border-radius:50%;
  margin-right:6px;
  box-shadow:0 0 0 1px rgba(0,0,0,.6);
}

.net-pill-dot.good { background:#2ecc71; }
.net-pill-dot.warn { background:#f1c40f; }
.net-pill-dot.bad  { background:#e74c3c; }
.net-pill-dot.unknown { background:#555; }

/* Legend text under the rows */
.net-legend {
  margin-top:6px;
  font-size:11px;
  opacity:.7;
  line-height:1.4;
}

.net-legend span.label {
  font-weight:600;
  margin-right:4px;
}

/* House health layout */
#card-house .house-room-list{
  margin-top:4px;
}
.house-room{
  display:flex;
  justify-content:space-between;
  font-size:14px;
  padding:2px 0;
}
.house-room .room-name{
  opacity:.85;
}
.house-room .room-temp{
  font-weight:600;
}
.house-room .room-temp.cold{
  color:#7fb6ff;    /* cool blue for cold rooms */
}
.house-room .room-temp.hot{
  color:#ff9b9b;    /* soft red for warm rooms */
}



/* Bottom row: slideshow on the left, health cards stacked on the right */
.card-row-bottom{
  grid-column:1 / -1;
  display:grid;
  grid-template-columns:minmax(0,3fr) minmax(0,1fr);
  gap:12px;
  align-items:flex-start;
}




.card-stack-right{
  display:grid;
  grid-auto-rows:minmax(min-content,max-content);
  gap:12px;
}

/* Tighter photo card framing */
#card-slideshow{ padding:8px; }
#card-slideshow .frame{ border:1px solid rgba(255,255,255,.35); border-radius:6px; overflow:hidden; display:flex; justify-content:flex-start; align-items:flex-start; }
#card-slideshow .frame img{ display:block; width:auto; max-width:100%; height:auto; max-height:40vh; }
#card-slideshow .muted{ margin-top:6px; }
.cell{
  min-height:120px;
  background:#1b1f29;           /* slightly lighter than before for better contrast */
  border:1px solid #333;        /* softer, consistent gray lines */
  border-radius:8px;
  padding:8px;
  min-width:0;
}
.date{opacity:.75;font-weight:700;text-align:right;font-size:20px}
/* header row inside a day cell: all-day pills left, date right */
.cell-head{display:flex;justify-content:space-between;align-items:flex-start;gap:8px;margin-bottom:6px}
.allbar{display:flex;flex-wrap:wrap;gap:6px;align-content:flex-start;overflow:hidden}
/* ---- Events ------------------------------------------------------------- */
  .evt{
    color:#e8ecf3;                /* crisp event text */
    white-space:normal;
    overflow-wrap:break-word;
    text-overflow:clip;
    background: var(--c);
    color:#fff;
    border-radius:6px;
    padding:2px 8px;
    margin:.18rem 0;
    font-size: var(--sz, 16px);
    display:flex;                 /* allow inline badges */
    align-items:flex-start;
    gap:6px;
    overflow:hidden;              /* clip text when it reaches the pill bottom */
  }
/* ensure flex children truncate nicely so widths stay uniform */
.evt{ min-width:0; }
.evt b{ flex:0 0 auto; }
.evt span{ flex:1 1 auto; min-width:0; overflow:hidden; white-space:normal; overflow-wrap:break-word; display:block; }
/* all‑day or multi‑day highlight tint for readability on dark ui */
.all{
  background: var(--c);
  border-radius:6px;
  padding:2px 8px;
}
/* compact pill tag for all-day entries */
.tag-all{
  font-size:14px;
  padding:0 6px;
  flex:0 0 auto;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  background: var(--c);
  color:#fff;
  max-width:100%;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  opacity:.9;
}
/* subtle de-emphasis for trailing author */
.who{opacity:.75}
.evt b{font-weight:700}
.evt span, .evt b { color:#fff; text-shadow:0 1px 1px rgba(0,0,0,.25); }
/* ---- Time grid (7:00–19:00 in 30-min slots) ----------------------------- */
.timegrid{--gutter:60px;display:grid;grid-template-rows:repeat(32,28px);row-gap:0;margin:6px 0 8px 0;position:relative}
.slot{border-top:1px dashed #2a3750;position:relative; z-index:0}
.slot.hour{border-top:1px solid #3b5172}
.slot .label{position:absolute;left:4px;top:-9px;font-size:11px;opacity:.65;user-select:none}
/* events placed into time slots */
.slot .evt{ margin:2px 4px; width:auto; }
/* absolute-positioned duration blocks */
.timegrid{ position:relative; }
.timegrid .overlay{ position:absolute; top:0; bottom:0; left:var(--gutter); right:0; z-index:2; pointer-events:none; }
.timegrid .overlay .evt{ position:absolute; left:2px; right:2px; margin:0; padding-top:4px; }
/* ---- Footer buttons ----------------------------------------------------- */
.footer{position:fixed;left:0;right:0;bottom:0;background:#0f1217;border-top:1px solid #1a1d22;padding:8px;display:flex;gap:8px;justify-content:center}
.footer button{
  background:#1a2333;
  color:#f2f5f9;
  border:1px solid #2a3750;
  border-radius:10px;
  padding:10px 14px;
  font-weight:600;
  cursor:pointer;
  transition:transform .06s ease, background .12s ease, border-color .12s ease
}
.footer button:hover{transform:translateY(-1px);background:#21314a;border-color:#3b5172}
.footer button:active{transform:translateY(0)}

/* ---- Slide-out menu ----------------------------------------------------- */
#gear{position:fixed;top:14px;right:14px;background:#1a2333;border:1px solid #2a3750;color:#f2f5f9;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer;z-index:20}
.drawer{position:fixed;top:0;right:-380px;width:360px;height:100vh;background:#0e1218;border-left:1px solid #22293a;box-shadow: -12px 0 24px rgba(0,0,0,.35);transition:right .18s ease;z-index:30;display:flex;flex-direction:column}
.drawer.open{right:0}
.drawer header{padding:16px;border-bottom:1px solid #1a1d22;font-weight:700}
.drawer .body{padding:16px;overflow:auto;flex:1}
.row{display:flex;align-items:center;gap:8px;margin-bottom:10px}
.row input[type="text"]{flex:1;background:#141b24;border:1px solid #283246;border-radius:8px;padding:8px;color:#f2f5f9}
.row input[type="number"]{background:#141b24;border:1px solid #283246;border-radius:8px;padding:8px;color:#f2f5f9}
.actions{padding:12px 16px;border-top:1px solid #1a1d22;display:flex;gap:8px;justify-content:flex-end}
.actions button{background:#1a2333;color:#f2f5f9;border:1px solid #2a3750;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
.actions button:hover{background:#21314a;border-color:#3b5172}
#card-nfl{position:relative;padding-bottom:32px;} #nfl-logo{position:absolute;bottom:8px;right:8px;width:55px;height:auto;opacity:0.9;}
</style>

<div id="gear">⚙ Calendars</div>

<div class="wrap">
  {{ people|json_script:"people-data" }}
  <h1>DayBuddy – Week View VERSION 33</h1>
  <div id="updated-at" style="text-align:left;opacity:.65;font-size:13px;margin-top:0;">
    Updated at —
  </div>
  <h3 style="text-align:center;opacity:.8;margin-top:12px;margin-bottom:4px;font-weight:600;">Week Legend</h3>
  <div class="legend">
    {% for p in people %}<span class="pill" style="--c:{{p.color}}">{{p.name}}</span>{% endfor %}
  </div>
  <div class="grid">
    {% for cell in cells %}
      <div class="cell">
        <div class="cell-head">
          <div class="allbar">
            {% for e in cell.events %}
              {% if e.all_day %}
                {% if e.title or e.time_label %}
                  <span class="tag-all" style="--c:{{ e.color }}">{{ e.title|default:"ALL DAY" }}</span>
                {% endif %}
              {% endif %}
            {% endfor %}
          </div>
          <div class="date">{{ cell.pretty }}</div>
        </div>
        <div class="timegrid"><div class="overlay"></div></div>
        {% for e in cell.events %}
          {% if not e.all_day %}
            {% if e.title or e.time_label %}
              <div class="evt" data-start="{{ e.time_label|default:'' }}" data-end="{{ e.end_time_label|default:'' }}" style="--c:{{e.color}};--sz:{{ e.font_size|default:16 }}px">
                <span>{% if e.title %}{{ e.title }}{% endif %}</span>
              </div>
            {% endif %}
          {% endif %}
        {% endfor %}
      </div>
    {% endfor %}
  </div>
  <div class="cards" id="weather-cards">
    <div class="card" id="card-now">
      <h4>Red Bank, NJ (07701) — Now</h4>
      <div class="big" id="now-temp">—</div>
      <div class="muted" id="now-sun">Sunrise: — • Sunset: —</div>
    </div>
    <div class="card" id="card-forecast">
      <h4>Temperature & Rain Chance (next 7 days)</h4>
      <svg id="wxChart" viewBox="0 0 1400 220" preserveAspectRatio="none"></svg>
      <div class="muted" id="wxNote">
        <span class="wx-key"><span class="sw temp"></span> Temperature (°F)</span>
        <span class="wx-key"><span class="sw precip"></span> Chance of Precip (%)</span>
      </div>
    </div>



    <div class="card-row-schedules">
      <div class="card" id="card-rangers">

        <h4 style="display:flex;justify-content:space-between;align-items:center;">
          <span style="font-size:13px;opacity:.75;">
            <span>NY Rangers – Next 7 Days   </span>
            <span style="
              display:inline-block;
              width:14px;
              height:14px;
              background:#01562e;
              border:1px solid #38a66f;
              border-radius:3px;
              margin-left:12px;
              margin-right:6px;
              vertical-align:middle;
            "></span>
            MSG Broadcast
          </span>


        </h4>        
        <div id="rangers-sched">Loading schedule… </div>
        <div id="devils-suck">DEVILS SUCK</div>

        <img id="rangers-logo" src="https://a.espncdn.com/i/teamlogos/nhl/500/nyr.png" style="width:8%;height:auto;" alt="New York Rangers logo">
      </div>
      <div class="card" id="card-nfl">
        <h4 style="display:flex;justify-content:space-between;align-items:center;">


          <span>NFL – Next 7 Days</span>
          <span style="font-size:13px;opacity:.75;display:flex;gap:10px;">
            <span style="margin-right:12px;">
              L = Local &nbsp;&nbsp; Y = YouTube &nbsp;&nbsp; P = Prime &nbsp;&nbsp; O = Other
            </span>            
            <span><span style="color:#7fb6ff;">●</span> Early Afternoon</span>
            <span><span style="color:#ffe48a;">●</span> Late Afternoon</span>
            <span><span style="color:#ff9b9b;">●</span> Night/Evening</span>
          </span>
        </h4>
        <div id="nfl-sched">Coming soon</div>
        <img
          id="nfl-logo"
          src="https://upload.wikimedia.org/wikipedia/en/a/a2/National_Football_League_logo.svg"
          alt="NFL logo">      </div>
    </div>
    <div class="card-row-bottom">
      <div class="card" id="card-slideshow">
        <h4>Family Photos</h4>
        <div class="frame">
          <img id="slide-img" alt="slideshow" style="opacity:.0;transition:opacity .5s ease;">
        </div>
        <div id="slide-bar">
          <div class="qr">
            <img src="/houseboard/daybuddy/qr" alt="Upload QR" style="max-width:100px">
            <div class="muted">
              <a href="http://161.35.180.75:8821/houseboard/daybuddy/photos/upload/" target="_blank" style="color:inherit;text-decoration:underline;">
                Go here to add pictures to the slideshow
              </a>
            </div>
          </div>
          <div class="meta-area">
            <div class="muted meta" id="slide-meta"></div>
            <button id="archive-photo-btn" type="button">Archive this photo</button>
          </div>
        </div>
      </div>


      <div class="card-stack-right">
        <div class="card" id="card-network">
          <h4>Network Health</h4>
          <div class="muted" id="net-wifi">
            <span class="net-pill-dot unknown"></span>
            Wi-Fi health: —
          </div>
          <div class="muted" id="net-internet">
            <span class="net-pill-dot unknown"></span>
            Internet health: —
          </div>
          <div class="muted net-legend">
            <div><span class="label">Good</span> Wi-Fi ≥ 70% quality and latency ≤ 40&nbsp;ms</div>
            <div><span class="label">Okay</span> Wi-Fi ≥ 40% or latency ≤ 120&nbsp;ms</div>
            <div><span class="label">Poor</span> Wi-Fi &lt; 40% or latency &gt; 120&nbsp;ms</div>
          </div>
        </div>

        <div class="card" id="card-house">
          <h4>House Health</h4>
          <div class="muted" id="house-summary">Rooms: —</div>
          <div class="muted house-room-list" id="house-rooms">
            <div>Loading rooms…</div>
          </div>
        </div>

      </div>
    </div>










      <!-- <div class="card-stack-right">
        <div class="card" id="card-network">
          <h4>Network Health</h4>
          <div class="muted" id="net-wifi">Wi‑Fi health: —</div>
          <div class="muted" id="net-internet">Internet health: —</div>
        </div>
        <div class="card" id="card-house">
          <h4>House Health</h4>
          <div class="muted" id="house-temp">House temperature: —</div>
          <div class="muted" id="house-alerts">Alerts: —</div>
        </div>
      </div>
    </div> -->







  </div>
</div>



<div class="drawer" id="drawer">
  <header>Edit calendars</header>
  <div class="body" id="drawer-body"></div>
  <div class="actions">
    <button id="cancel">Close</button>
    <button id="save">Save</button>
  </div>
</div>

<div class="footer">
  <button data-act="prev">◀ Prev</button>
  <button data-act="today">Today</button>
  <button data-act="next">Next ▶</button>
  <button data-act="mode">Mode</button>
  <button data-act="open">Open</button>
</div>

<script>
function goDate(y,m,d){
  const u = new URL(location);
  u.searchParams.set('y', y);
  u.searchParams.set('m', m);
  u.searchParams.set('d', d);
  location = u.toString();
}

const now = new Date();

// Show a small "Updated at" line under the heading
(function(){
  const el = document.getElementById('updated-at');
  if (!el) return;
  const opts = { hour: 'numeric', minute: '2-digit', hour12: true };
  const t = now.toLocaleTimeString([], opts);
  el.textContent = `Updated at ${t}`;
})();

function getAnchor(){
  const u = new URL(location);
  const yy = parseInt(u.searchParams.get('y') || now.getFullYear());
  const mm = parseInt(u.searchParams.get('m') || (now.getMonth()+1));
  const dd = parseInt(u.searchParams.get('d') || now.getDate());
  return new Date(yy, mm-1, dd);
}
const anchor = getAnchor();

document.querySelector('[data-act="prev"]').onclick = () => {
  const d = new Date(anchor);
  d.setDate(d.getDate() - 7);
  goDate(d.getFullYear(), d.getMonth()+1, d.getDate());
};

document.querySelector('[data-act="next"]').onclick = () => {
  const d = new Date(anchor);
  d.setDate(d.getDate() + 7);
  goDate(d.getFullYear(), d.getMonth()+1, d.getDate());
};

document.querySelector('[data-act="today"]').onclick = () => {
  goDate(now.getFullYear(), now.getMonth()+1, now.getDate());
};

// People data for drawer
const PEOPLE = JSON.parse(document.getElementById('people-data').textContent);

const gear = document.getElementById('gear');
const drawer = document.getElementById('drawer');
const bodyEl = document.getElementById('drawer-body');
const cancelBtn = document.getElementById('cancel');
const saveBtn = document.getElementById('save');

function buildTimeGrid(el){
  // 32 slots: 6:00, 6:30, …, 21:30 (ending right at 22:00)
  const startMinutes = 6*60; // 6:00
  for (let i=0;i<32;i++){
    const m = startMinutes + i*30;
    const hh = Math.floor(m/60);
    const mm = m%60;
    const isHour = (mm===0);
    const label = isHour ? ((hh%12||12)+":00"+(hh<12?"a":"p")) : ((hh%12||12)+":30"+(hh<12?"a":"p"));
    const div = document.createElement('div');
    div.className = 'slot' + (isHour ? ' hour' : '');
    if(isHour){
      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = label;
      div.appendChild(span);
    }
    el.appendChild(div);
  }
  const ov = el.querySelector('.overlay'); if(ov) el.appendChild(ov);
}

// Populate all timegrids in the week view

for (const tg of document.querySelectorAll('.timegrid')) buildTimeGrid(tg);

function parseStartMinutes(label){
  if(!label) return null;
  // Accept forms like "7:00 AM", "7:30PM", "7a", "7:30p"
  const s = label.trim().toLowerCase().replace(/\s+/g,'');
  const m = s.match(/^(\d{1,2})(?::(\d{2}))?([ap])m?$/);
  if(!m) return null;
  let h = parseInt(m[1],10);
  let min = m[2] ? parseInt(m[2],10) : 0;
  const ap = m[3];
  h = h % 12 + (ap === 'p' ? 12 : 0);
  return h*60 + min;
}

function placeEventsIntoGrid(){
  const SLOT_PX = 28;           // matches CSS row height
  const WINDOW_START = 6*60;    // 360 = 6:00
  const WINDOW_END   = 22*60;   // 1320 = 22:00

  const CELLS = document.querySelectorAll('.cell');
  for (const cell of CELLS){
    const grid = cell.querySelector('.timegrid');
    if (!grid) continue;
    const overlay = grid.querySelector('.overlay');
    if (!overlay) continue;

    // Collect all non-all-day event nodes for this cell
    const nodes = [...cell.querySelectorAll('.evt')].filter(e => e.closest('.cell') === cell);

    // Build a list of positioned items with start/end in minutes
    const items = [];
    for (const evt of nodes){
      const startLabel = (evt.getAttribute('data-start') || '').trim();
      const endLabel   = (evt.getAttribute('data-end') || '').trim();

      let startMin = parseStartMinutes(startLabel);
      if (startMin == null) continue;  // skip if we cannot place

      let endMin = parseStartMinutes(endLabel);
      if (endMin == null || endMin <= startMin) {
        // Default to 1‑hour duration if no valid end time
        endMin = startMin + 60;
      }

      // Clamp to visible window
      let s = startMin;
      let e = endMin;
      if (e <= WINDOW_START || s >= WINDOW_END) {
        // Completely outside visible window
        continue;
      }
      s = Math.max(s, WINDOW_START);
      e = Math.min(e, WINDOW_END);

      const top = ((s - WINDOW_START) / 30) * SLOT_PX;
      const h   = Math.max(20, ((e - s) / 30) * SLOT_PX - 4);

      items.push({
        node: evt,
        start: s,
        end: e,
        top,
        height: h,
      });
    }

    if (!items.length) continue;

    // Sort by start time (then by longer duration first for stability)
    items.sort((a, b) => {
      if (a.start !== b.start) return a.start - b.start;
      return (b.end - b.start) - (a.end - a.start);
    });

    // Group events into overlapping clusters
    const groups = [];
    let current = [];
    let currentEnd = null;
    for (const item of items){
      if (!current.length){
        current.push(item);
        currentEnd = item.end;
      } else if (item.start < currentEnd){
        // overlaps with current group
        current.push(item);
        currentEnd = Math.max(currentEnd, item.end);
      } else {
        // new, non-overlapping group
        groups.push(current);
        current = [item];
        currentEnd = item.end;
      }
    }
    if (current.length) groups.push(current);

    // For each overlapping group, assign columns and compute widths
    for (const group of groups){
      // columns[c] will hold the "last end time" for that column
      const columns = [];

      for (const item of group){
        let placed = false;
        for (let c = 0; c < columns.length; c++){
          if (item.start >= columns[c]){
            // This event can reuse column c
            columns[c] = item.end;
            item.colIndex = c;
            placed = true;
            break;
          }
        }
        if (!placed){
          // Start a new column
          columns.push(item.end);
          item.colIndex = columns.length - 1;
        }
      }

      const colCount = columns.length || 1;
      const widthPct = 100 / colCount;

      for (const item of group){
        const evt = item.node;
        const leftPct = widthPct * item.colIndex;

        evt.style.position = 'absolute';
        evt.style.top = item.top + 'px';
        evt.style.height = item.height + 'px';
        // Use percentage‑based layout inside the overlay so overlapping
        // events sit side‑by‑side instead of on top of each other.
        evt.style.left = `calc(${leftPct}% + 2px)`;
        evt.style.width = `calc(${widthPct}% - 4px)`;
        evt.style.right = 'auto';

        overlay.appendChild(evt);
      }
    }
  }
}

placeEventsIntoGrid();

function openDrawer(){
  bodyEl.innerHTML = PEOPLE.map(p => `
    <div class="row" data-id="${p.id}">
      <input type="color" class="clr" value="${p.color}" title="Pick color" />
      <input type="text" class="nm" value="${p.name}" placeholder="Display name" />
      <input type="number" class="fs" value="${p.font_size || 16}" min="10" max="24" step="1" style="width:72px" />
    </div>
  `).join('');
  drawer.classList.add('open');
}
function closeDrawer(){ drawer.classList.remove('open'); }

gear.addEventListener('click', openDrawer);
cancelBtn.addEventListener('click', closeDrawer);

saveBtn.addEventListener('click', async () => {
  const rows = [...bodyEl.querySelectorAll('.row')];
  for (const r of rows) {
    const id = r.getAttribute('data-id');
    const name = r.querySelector('input.nm').value.trim();
    const fs   = parseInt(r.querySelector('input.fs').value,10) || 16;
    const color = (r.querySelector('input.clr')?.value || '').trim();
    if (!id || !name) continue;
    try {
      const res = await fetch('/houseboard/daybuddy/rename', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({id, name, font_size: fs, color})
      });
      if (!res.ok) {
        console.error('Rename failed for', id, await res.text());
      }
    } catch(e) {
      console.error(e);
    }
  }
  location.reload();
});

// ---- Weather: 07701 (Red Bank, NJ) --------------------------------------
async function loadWeather(){
  try{
    const LAT = 40.35, LON = -74.07; // Red Bank approx
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&hourly=temperature_2m,precipitation_probability&daily=sunrise,sunset&current=temperature_2m&temperature_unit=fahrenheit&timezone=America%2FNew_York&forecast_days=10`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('Weather fetch failed');
    const data = await res.json();

    // 1) Current temperature card
    const nowEl = document.getElementById('now-temp');
    if(data.current && typeof data.current.temperature_2m === 'number'){
      nowEl.innerHTML = Math.round(data.current.temperature_2m) + '<span class="unit">°F</span>';
    } else {
      nowEl.textContent = '—';
    }
    // Sunrise/Sunset for today (combined line)
    const sunEl = document.getElementById('now-sun');
    if (data.daily && data.daily.sunrise && data.daily.sunset && data.daily.sunrise.length > 0) {
      const srTime = new Date(data.daily.sunrise[0]);
      const ssTime = new Date(data.daily.sunset[0]);
      const fmt = (d) => d.toLocaleTimeString([], {hour:'numeric', minute:'2-digit'});
      sunEl.textContent = 'Sunrise: ' + fmt(srTime) + ' • Sunset: ' + fmt(ssTime);
    } else {
      sunEl.textContent = 'Sunrise: — • Sunset: —';
    }

    // 2) Forecast chart (next 72 hours)
    const hours = data.hourly?.time || [];
    const temps = data.hourly?.temperature_2m || [];
    const pops  = data.hourly?.precipitation_probability || [];
    const takeN = Math.min(hours.length, 168); // next 7 days

    const pts = [];
    const bars = [];
    let tmin = Infinity, tmax = -Infinity;
    for(let i=0;i<takeN;i++){
      const t = temps[i];
      if(typeof t === 'number'){
        tmin = Math.min(tmin, t); tmax = Math.max(tmax, t);
      }
    }
    if(!isFinite(tmin) || !isFinite(tmax)) { tmin = 30; tmax = 90; }
    // pad range a little
    const pad = 2; tmin -= pad; tmax += pad;

    // SVG size (viewBox 0..1400 x 0..220)
    const W=1400, H=220;
    const tempTop = 10, tempBottom = 130; // top region for temp line
    const barBottom = H-20, barMaxH = 70; // lower region for precip bars

    const xStep = (W-20) / Math.max(1, takeN-1);
    for(let i=0;i<takeN;i++){
      const x = 10 + i*xStep;
      const t = temps[i];
      const p = (typeof pops[i] === 'number') ? pops[i] : 0;
      // map temp to y
      const y = (1 - (t - tmin)/(tmax - tmin)) * (tempBottom - tempTop) + tempTop;
      pts.push(`${x},${y}`);
      // precip bar
      const bh = Math.max(0, Math.min(barMaxH, (p/100)*barMaxH));
      bars.push({x, y: barBottom - bh, h: bh});
    }

    const svg = document.getElementById('wxChart');
    // clear
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    // day bands & labels (start/end of each day)
    const dayGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    // dayGroup opacity removed so labels render full-white

    // Find indices where a new day starts
    const dayBreakIdx = [0];
    for(let i=1;i<takeN;i++){
      const dPrev = new Date(hours[i-1]);
      const dCurr = new Date(hours[i]);
      if(dPrev.getDate() !== dCurr.getDate() || dPrev.getMonth() !== dCurr.getMonth()){
        dayBreakIdx.push(i);
      }
    }
    // ensure we close the last segment
    if(dayBreakIdx[dayBreakIdx.length-1] !== takeN-1){
      dayBreakIdx.push(takeN-1);
    }

    for(let k=0;k<dayBreakIdx.length-1;k++){
      const s = dayBreakIdx[k];
      const e = dayBreakIdx[k+1];
      const x1 = 10 + s*xStep;
      const x2 = 10 + e*xStep;
      const w  = Math.max(1, x2 - x1);

      // alternating subtle background band
      const band = document.createElementNS('http://www.w3.org/2000/svg','rect');
      band.setAttribute('x', x1);
      band.setAttribute('y', 8);
      band.setAttribute('width', w);
      band.setAttribute('height', H-30);
      band.setAttribute('fill', (k % 2 === 0) ? '#4e7ad9' : '#4e7ad9');
      band.setAttribute('opacity', (k % 2 === 0) ? '0.40' : '0.40');
      dayGroup.appendChild(band);

      // day boundary line at start
      const dl = document.createElementNS('http://www.w3.org/2000/svg','line');
      dl.setAttribute('x1', x1);
      dl.setAttribute('y1', 8);
      dl.setAttribute('x2', x1);
      dl.setAttribute('y2', H-22);
      dl.setAttribute('stroke', '#a8b6d2');
      dl.setAttribute('stroke-width', '1');
      dl.setAttribute('opacity', '0.55');
      dayGroup.appendChild(dl);

      // day label (e.g., Mon 11/09) centered in band
      const labelDate = new Date(hours[s]);
      const dow = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][labelDate.getDay()];
      const mon = labelDate.getMonth()+1;
      const day = labelDate.getDate();
      const cx = x1 + w/2;
      const tLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      tLabel.setAttribute('x', cx);
      tLabel.setAttribute('y', tempTop + 12);
      tLabel.setAttribute('text-anchor', 'middle');
      tLabel.setAttribute('fill', '#ffffff');
      tLabel.setAttribute('font-size', '12');
      tLabel.textContent = `${dow} ${mon}/${day}`;
      dayGroup.appendChild(tLabel);
    }
    svg.appendChild(dayGroup);

    // night bands: from daily sunset to next day's sunrise
    if (data.daily && Array.isArray(data.daily.sunset) && Array.isArray(data.daily.sunrise)){
      const nightGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
      nightGroup.setAttribute('opacity','0.08');
      nightGroup.setAttribute('stroke','none');
      const X_MIN = 10, X_MAX = 10 + (takeN-1)*xStep;
      const yTop = 8, yBot = H-22;

      const findX = (dt) => {
        // find first hourly index >= dt
        for(let i=0;i<takeN;i++){
          const hi = new Date(hours[i]).getTime();
          if (hi >= dt.getTime()){
            const x = X_MIN + i*xStep;
            return Math.min(X_MAX, Math.max(X_MIN, x));
          }
        }
        return null;
      };

      const sunr = data.daily.sunrise;
      const suns = data.daily.sunset;
      const daysN = Math.min(sunr.length, suns.length);

      for(let k=0;k<daysN;k++){
        const sunset = new Date(suns[k]);
        const nextSunrise = (k+1 < sunr.length) ? new Date(sunr[k+1]) : null;
        if(!nextSunrise) continue;
        let x1 = findX(sunset);
        let x2 = findX(nextSunrise);
        // if next sunrise is beyond plotted range but we have sunset inside, fill to end
        if (x1==null && x2==null) continue; // both out of range
        if (x1==null && x2!=null) x1 = X_MIN; // started before range
        if (x1!=null && x2==null) x2 = X_MAX; // ends after range
        if (x1!=null && x2!=null && x2 > x1){
          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('x', x1);
          rect.setAttribute('y', yTop);
          rect.setAttribute('width', x2 - x1);
          rect.setAttribute('height', yBot - yTop);
          rect.setAttribute('fill', '#ffffff'); // light night tint after flip
          nightGroup.appendChild(rect);
        }
      }
      svg.appendChild(nightGroup);
    }

    // grid lines each 12 hours
    const grid = document.createElementNS('http://www.w3.org/2000/svg','g');
    grid.setAttribute('opacity','0.2');
    for(let i=0;i<takeN;i++){
      const dt = new Date(hours[i]);
      if(dt.getHours()===0 || dt.getHours()===12){
        const x = 10 + i*xStep;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x); line.setAttribute('y1',8);
        line.setAttribute('x2',x); line.setAttribute('y2',H-22);
        line.setAttribute('stroke','#9fb3d1'); line.setAttribute('stroke-width','1'); line.setAttribute('stroke-dasharray','3,3');
        grid.appendChild(line);
      }
    }
    svg.appendChild(grid);
    // bottom axis ticks and labels for 12am / 12pm
    const bottomAxis = document.createElementNS('http://www.w3.org/2000/svg','g');
    const yBottomAxis = H - 22; // chart bottom line
    for(let i=0;i<takeN;i++){
      const dt = new Date(hours[i]);
      const hr = dt.getHours();
      if(hr === 0 || hr === 12){
        const x = 10 + i*xStep;
        // tick mark
        const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
        tick.setAttribute('x1', x);
        tick.setAttribute('y1', yBottomAxis);
        tick.setAttribute('x2', x);
        tick.setAttribute('y2', yBottomAxis - 6);
        tick.setAttribute('stroke', '#e6efff');
        tick.setAttribute('stroke-width', '1');
        bottomAxis.appendChild(tick);
        // label
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('x', x);
        lbl.setAttribute('y', H - 6);
        lbl.setAttribute('text-anchor', 'middle');
        lbl.setAttribute('fill', '#ffffff');
        lbl.setAttribute('font-size', '10');
        lbl.textContent = (hr === 0) ? '12am' : '12pm';
        bottomAxis.appendChild(lbl);
      }
    }
    svg.appendChild(bottomAxis);

    // precip y-axis markers at 25/50/75/100%
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg','g');
    const pctMarks = [25,50,75,100];
    for(const pct of pctMarks){
      const y = barBottom - (pct/100)*barMaxH;
      // tick line across precip band
      const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
      tick.setAttribute('x1', 10);
      tick.setAttribute('y1', y);
      tick.setAttribute('x2', W-10);
      tick.setAttribute('y2', y);
      tick.setAttribute('stroke', '#a8b6d2');
      tick.setAttribute('stroke-width', '1');
      tick.setAttribute('stroke-dasharray', '2,4');
      tick.setAttribute('opacity', '0.55');
      yAxis.appendChild(tick);

      // right-side label
      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('x', W-8);
      lbl.setAttribute('y', y-2);
      lbl.setAttribute('text-anchor', 'end');
      lbl.setAttribute('fill', '#e6efff');
      lbl.setAttribute('font-size', '12');
      lbl.textContent = pct + '%';
      yAxis.appendChild(lbl);
    }
    svg.appendChild(yAxis);

    // temperature y-axis markers at 25/50/75/100 °F (only if within range)
    const tAxis = document.createElementNS('http://www.w3.org/2000/svg','g');
    const tMarks = [25,50,75,100];
    for(const val of tMarks){
      if(!(val >= tmin && val <= tmax)) continue; // skip values outside current plotted temp range
      const yT = (1 - (val - tmin)/(tmax - tmin)) * (tempBottom - tempTop) + tempTop;
      // tick line across the temperature band
      const tLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      tLine.setAttribute('x1', 10);
      tLine.setAttribute('y1', yT);
      tLine.setAttribute('x2', W-10);
      tLine.setAttribute('y2', yT);
      tLine.setAttribute('stroke', '#a8b6d2');
      tLine.setAttribute('stroke-width', '1');
      tLine.setAttribute('stroke-dasharray', '2,4');
      tLine.setAttribute('opacity', '0.55');
      tAxis.appendChild(tLine);

      // left-side label (avoid overlap with precip labels on the right)
      const tLbl = document.createElementNS('http://www.w3.org/2000/svg','text');
      tLbl.setAttribute('x', 12);
      tLbl.setAttribute('y', yT-2);
      tLbl.setAttribute('text-anchor', 'start');
      tLbl.setAttribute('fill', '#f0f6ff');
      tLbl.setAttribute('font-size', '12');
      tLbl.textContent = `${val}°F`;
      tAxis.appendChild(tLbl);
    }
    svg.appendChild(tAxis);

    // precip area (filled, continuous)
    const areaPts = [];
    // start at left baseline
    areaPts.push(`10,${barBottom}`);
    for(let i=0;i<takeN;i++){
      const x = 10 + i*xStep;
      const p = (typeof pops[i] === 'number') ? pops[i] : 0;
      const bh = Math.max(0, Math.min(barMaxH, (p/100)*barMaxH));
      const y = barBottom - bh;
      areaPts.push(`${x},${y}`);
    }
    // end at right baseline
    areaPts.push(`${10 + (takeN-1)*xStep},${barBottom}`);

    const area = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    area.setAttribute('points', areaPts.join(' '));
    area.setAttribute('fill', '#00a8ff');
    area.setAttribute('opacity', '0.6');
    svg.appendChild(area);

    // optional precip outline for clarity
    const precipLinePts = [];
    for(let i=0;i<takeN;i++){
      const x = 10 + i*xStep;
      const p = (typeof pops[i] === 'number') ? pops[i] : 0;
      const bh = Math.max(0, Math.min(barMaxH, (p/100)*barMaxH));
      const y = barBottom - bh;
      precipLinePts.push(`${x},${y}`);
    }
    const precipLine = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    precipLine.setAttribute('fill','none');
    precipLine.setAttribute('stroke','#008ce0');
    precipLine.setAttribute('stroke-width','2');
    precipLine.setAttribute('points', precipLinePts.join(' '));
    svg.appendChild(precipLine);

    // temp line
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    poly.setAttribute('fill','none');
    poly.setAttribute('stroke','#ffd27d');
    poly.setAttribute('stroke-width','2');
    poly.setAttribute('points', pts.join(' '));
    svg.appendChild(poly);

    // min/max labels
    const lblMin = document.createElementNS('http://www.w3.org/2000/svg','text');
    lblMin.setAttribute('x','8'); lblMin.setAttribute('y',tempBottom+12);
    lblMin.setAttribute('fill','#9fb3d1'); lblMin.setAttribute('font-size','12');
    lblMin.textContent = `${Math.round(tmin)}°F`;
    svg.appendChild(lblMin);

    const lblMax = document.createElementNS('http://www.w3.org/2000/svg','text');
    lblMax.setAttribute('x','8'); lblMax.setAttribute('y',tempTop+12);
    lblMax.setAttribute('fill','#9fb3d1'); lblMax.setAttribute('font-size','12');
    lblMax.textContent = `${Math.round(tmax)}°F`;
    svg.appendChild(lblMax);

  }catch(err){
    console.error(err);
    const nowEl = document.getElementById('now-temp');
    if(nowEl) nowEl.textContent = 'N/A';
  }
}


// Network health checker with color-coded status
async function loadNetworkHealth(){
  const wifiEl = document.getElementById('net-wifi');
  const inetEl = document.getElementById('net-internet');
  const card   = document.getElementById('card-network');
  if (!wifiEl || !inetEl || !card) return;

  // Default content while fetching
  wifiEl.innerHTML = '<span class="net-pill-dot unknown"></span>Wi-Fi health: checking…';
  inetEl.innerHTML = '<span class="net-pill-dot unknown"></span>Internet health: checking…';
  card.classList.remove('good','warn','bad','unknown');
  card.classList.add('unknown');

  // Parse something like "gooberbest (80% quality)" → 80
  function parseWifiPercent(detail) {
    if (!detail) return null;
    const m = detail.match(/(\d+)\s*%/);
    return m ? parseInt(m[1], 10) : null;
  }

  try {
    // Same endpoints you’re already using
    const candidates = [
      'http://127.0.0.1:8787/network',      // hb-pi kiosk
      'http://hb-pi:8787/network',          // hb-pi hostname
      'http://192.168.1.237:8787/network',  // hb-pi static LAN IP
    ];

    let j = null;
    let lastErr = null;

    for (const url of candidates) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
          lastErr = new Error('wifi_health HTTP ' + res.status + ' for ' + url);
          continue;
        }
        j = await res.json();
        break;
      } catch (inner) {
        lastErr = inner;
      }
    }

    if (!j) {
      throw lastErr || new Error('No wifi_health endpoint reachable');
    }

    const wifiStatus = j.wifi_status || 'unknown';
    const wifiDetail = j.wifi_detail || '';
    const internetStatus = j.internet_status || 'unknown';
    const internetDetail = j.internet_detail || '';
    const latencyMs = (typeof j.latency_ms === 'number') ? j.latency_ms : null;
    const latencyLabel = (latencyMs != null) ? `${latencyMs.toFixed(1)} ms` : '';

    const wifiPct = parseWifiPercent(wifiDetail);
    let state = 'unknown';

    // Classification rules:
    // Good  : Wi-Fi ≥ 70% AND latency ≤ 40 ms (when present)
    // Warn  : Wi-Fi ≥ 40% OR latency ≤ 120 ms
    // Bad   : everything else that isn't unknown
    if (wifiPct == null && latencyMs == null) {
      state = 'unknown';
    } else if (
      (wifiPct == null || wifiPct >= 70) &&
      (latencyMs == null || latencyMs <= 40)
    ) {
      state = 'good';
    } else if (
      (wifiPct != null && wifiPct >= 40) ||
      (latencyMs != null && latencyMs <= 120)
    ) {
      state = 'warn';
    } else {
      state = 'bad';
    }

    // Update card classes + text
    card.classList.remove('good','warn','bad','unknown');
    card.classList.add(state);

    wifiEl.innerHTML =
      `<span class="net-pill-dot ${state}"></span>` +
      'Wi-Fi health: ' + (wifiDetail || wifiStatus);

    inetEl.innerHTML =
      `<span class="net-pill-dot ${state}"></span>` +
      'Internet health: ' +
      (internetDetail || internetStatus) +
      (latencyLabel ? ` (${latencyLabel})` : '');

  } catch (e) {
    console.error('Network health check failed', e);
    card.classList.remove('good','warn','bad','unknown');
    card.classList.add('bad');
    wifiEl.innerHTML = '<span class="net-pill-dot bad"></span>Wi-Fi health: unknown';
    inetEl.innerHTML = '<span class="net-pill-dot bad"></span>Internet health: offline?';
  }
}

// House health: show rooms and their temperatures in °F
async function loadHouseHealth(){
  const listEl    = document.getElementById('house-rooms');
  const summaryEl = document.getElementById('house-summary');
  if (!listEl || !summaryEl) return;

  // Default state while loading
  listEl.innerHTML = '<div>Loading rooms…</div>';
  summaryEl.textContent = 'Rooms: —';

  try {
    // CANDIDATE ENDPOINTS:
    // Adjust these URLs to match your actual house temperature API.
  const candidates = [
    '/api/houseboard/house_temps/',
  ];

    let data = null;
    let lastErr = null;

    for (const url of candidates) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
          lastErr = new Error('house_health HTTP ' + res.status + ' for ' + url);
          continue;
        }
        data = await res.json();
        break;
      } catch (inner) {
        lastErr = inner;
      }
    }

    if (!data) {
      throw lastErr || new Error('No house temperature endpoint reachable');
    }

    // Accept either {rooms:[...]} or a bare array
    const rooms = Array.isArray(data.rooms) ? data.rooms :
                  (Array.isArray(data) ? data : []);

    if (!rooms.length) {
      listEl.innerHTML = '<div>No room data.</div>';
      summaryEl.textContent = 'Rooms: 0';
      return;
    }

    // Sort alphabetically by room name
    rooms.sort((a, b) => {
      const na = (a.room || a.name || '').toLowerCase();
      const nb = (b.room || b.name || '').toLowerCase();
      if (na < nb) return -1;
      if (na > nb) return 1;
      return 0;
    });

    // Build the HTML list
    const html = rooms.map(r => {
      const name = r.room || r.name || 'Room';
      let tempF = null;

      if (typeof r.temp_f === 'number') {
        tempF = r.temp_f;
      } else if (typeof r.temperature_f === 'number') {
        tempF = r.temperature_f;
      }

      const label = (tempF != null)
        ? `${tempF.toFixed(1)} °F`
        : '—';

      let cls = '';
      if (tempF != null) {
        if (tempF <= 65) cls = 'cold';
        else if (tempF >= 78) cls = 'hot';
      }

      return `
        <div class="house-room">
          <span class="room-name">${name}</span>
          <span class="room-temp ${cls}">${label}</span>
        </div>
      `;
    }).join('');

    listEl.innerHTML = html;
    summaryEl.textContent = `Rooms: ${rooms.length}`;

  } catch (e) {
    console.error('House health load failed', e);
    listEl.innerHTML = '<div>Error loading house temps</div>';
    summaryEl.textContent = 'Rooms: error';
  }
}





// // Network health checker
// async function loadNetworkHealth(){
//   const wifiEl = document.getElementById('net-wifi');
//   const inetEl = document.getElementById('net-internet');
//   if (!wifiEl || !inetEl) return;

//   // Default text while fetching
//   wifiEl.textContent = 'Wi‑Fi health: checking…';
//   inetEl.textContent = 'Internet health: checking…';

//   try {
//     // Try multiple possible endpoints so the card works both on the hb-pi
//     // itself (localhost) and when viewed from another device on the LAN.
//     const candidates = [
//       'http://127.0.0.1:8787/network',      // when viewed on hb-pi itself
//       'http://hb-pi:8787/network',     // hb-pi reachable by hostname
//       'http://192.168.1.237:8787/network',  // hb-pi reachable by static LAN IP
//     ];
//     let j = null;
//     let lastErr = null;
//     for (const url of candidates) {
//       try {
//         const res = await fetch(url, { cache: 'no-store' });
//         if (!res.ok) {
//           lastErr = new Error('wifi_health HTTP ' + res.status + ' for ' + url);
//           continue;
//         }
//         j = await res.json();
//         break;
//       } catch (inner) {
//         lastErr = inner;
//       }
//     }

//     if (!j) {
//       throw lastErr || new Error('No wifi_health endpoint reachable');
//     }

//     const wifiStatus = j.wifi_status || 'unknown';
//     const wifiDetail = j.wifi_detail || '';
//     const internetStatus = j.internet_status || 'unknown';
//     const internetDetail = j.internet_detail || '';
//     const latency = (typeof j.latency_ms === 'number')
//       ? `${j.latency_ms.toFixed(1)} ms`
//       : '';

//     wifiEl.textContent = 'Wi‑Fi health: ' + (wifiDetail || wifiStatus);
//     inetEl.textContent = 'Internet health: ' + (internetDetail || internetStatus) + (latency ? ` (${latency})` : '');
//   } catch (e) {
//     console.error('Network health check failed', e);
//     wifiEl.textContent = 'Wi‑Fi health: unknown';
//     inetEl.textContent = 'Internet health: offline?';
//   }
// }






// initial weather / health load
loadWeather();
loadNetworkHealth();
loadHouseHealth();
// --- Simple slideshow ---
(function(){
  const IMG = document.getElementById('slide-img');
  const META = document.getElementById('slide-meta');
  const ARCHIVE_BTN = document.getElementById('archive-photo-btn');
  if(!IMG) return; // card not present

  let timer = null;
  let currentId = null;

  // Helper to refresh all cards when a new photo loads
  async function refreshAllCards(){
    try{
      await Promise.all([
        loadWeather(),
        loadRangersSchedule(),
        loadNFLSchedule(),
        loadNetworkHealth(),
        loadHouseHealth(),
      ]);
    } catch(e) {
      console.error('refreshAllCards failed', e);
    }
    // Update the "Updated at" timestamp after all cards refresh
    const ua = document.getElementById('updated-at');
    if (ua) {
      const now2 = new Date();
      const opts2 = { hour: 'numeric', minute: '2-digit', hour12: true };
      ua.textContent = `Updated at ${now2.toLocaleTimeString([], opts2)}`;
    }
  }

  async function loadOne(attempt = 0) {
    try{
      const res = await fetch('/houseboard/daybuddy/photos/random', {cache:'no-store'});
      if(!res.ok) throw new Error('random fetch failed');
      const j = await res.json();
      if(!j || !j.url){
        META.textContent = 'No photos available';
        currentId = null;
        return;
      }

      // If we got the same photo again and we have more than one image
      // on the backend, retry a couple of times to avoid appearing "stuck".
      if (currentId && j.id && j.id === currentId && attempt < 3) {
        console.debug('Same photo as current, retrying...', attempt);
        return loadOne(attempt + 1);
      }

      currentId = j.id || null;
      const url = j.url + '?v=' + Date.now(); // cache-bust
      // fade out, swap, fade in
      IMG.style.opacity = 0;
      const preload = new Image();
      preload.onload = () => {
        IMG.src = url;
        IMG.onload = () => { IMG.style.opacity = 1; };
      };
      preload.src = url;

      let label = '';
      const datePart = j.taken_label || j.taken_at || '';
      let placePart = '';

      // Prefer human-friendly city/state from the backend, if available
      if (j.location_label) {
        placePart = `Photo taken at ${j.location_label}`;
      } else if (typeof j.lat === 'number' && typeof j.lon === 'number') {
        // Fallback to numeric lat/lon if we don't have a city/state label
        const latAbs = Math.abs(j.lat).toFixed(4);
        const lonAbs = Math.abs(j.lon).toFixed(4);
        const ns = j.lat >= 0 ? 'N' : 'S';
        const ew = j.lon >= 0 ? 'E' : 'W';
        placePart = `Photo taken at ${latAbs}°${ns}, ${lonAbs}°${ew}`;
      }

      if (placePart && datePart) {
        label = `${placePart} on ${datePart}`;
      } else if (datePart) {
        label = `Photo taken on ${datePart}`;
      } else if (placePart) {
        label = placePart;
      } else {
        label = '';
      }

      META.textContent = label || 'Photo';

      // After updating the photo, refresh the other dashboard cards
      refreshAllCards();
    }catch(e){
      console.error(e);
      if(META) META.textContent = 'No photos available';
      currentId = null;
    }
  }

  if (ARCHIVE_BTN) {
    ARCHIVE_BTN.addEventListener('click', async () => {
      if (!currentId) return;
      try{
        ARCHIVE_BTN.disabled = true;
        const res = await fetch('/houseboard/daybuddy/photos/archive', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({id: currentId})
        });
        if (!res.ok) {
          console.error('Archive failed', await res.text());
          META.textContent = 'Archive failed.';
          return;
        }
        META.textContent = 'Photo archived. Loading next photo…';
        await loadOne();
      }catch(e){
        console.error(e);
        META.textContent = 'Archive failed.';
      }finally{
        ARCHIVE_BTN.disabled = false;
      }
    });
  }

  function start(){
    loadOne();
    timer = setInterval(loadOne, 20000); // 20s cadence
  }

  // Pause/resume on click
  IMG.addEventListener('click', () => {
    if(timer){ clearInterval(timer); timer = null; META.textContent += ' • paused'; }
    else { META.textContent = META.textContent.replace(' • paused',''); start(); }
  });

  start();
})();

// --- Rangers schedule card ---
async function loadRangersSchedule(){
  const box = document.getElementById('rangers-sched');
  if (!box) return;

  try {
    const res = await fetch('/houseboard/daybuddy/nhl/rangers/schedule', { cache: 'no-store' });
    if (!res.ok) throw new Error('Rangers schedule HTTP ' + res.status);

    const data = await res.json();
    const games = Array.isArray(data.games) ? data.games : [];

    // Map games by ISO date string (YYYY-MM-DD)
    const byDate = new Map();
    games.forEach(g => {
      const iso = g.date || '';
      if (!iso) return;
      if (!byDate.has(iso)) byDate.set(iso, []);
      byDate.get(iso).push(g);
    });

    // Build 7 calendar days starting from today (local)
    const today = new Date();
    today.setHours(0,0,0,0);

    const grid = document.createElement('div');
    grid.id = 'rangers-grid';

    const DOW = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

    for (let i = 0; i < 7; i++) {
      const d = new Date(today);
      d.setDate(today.getDate() + i);
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      const iso = `${year}-${month}-${day}`;

      const cell = document.createElement('div');
      cell.className = 'rangers-day';

      const head = document.createElement('div');
      head.className = 'day-label';
      head.textContent = `${DOW[d.getDay()]} ${month}/${day}`;
      cell.appendChild(head);

      const dayGames = byDate.get(iso) || [];

      // Check if any game this day is broadcast on MSG
      const isMSG = dayGames.some(g => g.broadcast_class === 'msg');

      if (isMSG) {
        cell.classList.add('msg-day');
      }

      if (dayGames.length === 0) {
        const span = document.createElement('div');
        span.className = 'nogame';
        span.textContent = 'No game';
        cell.appendChild(span);
      } else {
        dayGames.forEach(g => {
          const opp = g.opponent || '';
          const ha = g.home_away || '';
          const time = g.time_label || '';
          const line = document.createElement('div');
          line.className = 'game';
          const parts = [];
          if (ha) parts.push(ha);
          if (time) parts.push(time);
          const suffix = parts.length ? ` (${parts.join(' • ')})` : '';
          line.textContent = opp + suffix;
          cell.appendChild(line);
        });
      }

      grid.appendChild(cell);
    }

    box.innerHTML = '';
    box.appendChild(grid);
  } catch (e) {
    console.error('Rangers schedule error:', e);
    box.textContent = 'Schedule unavailable.';
  }
}

// initial Rangers load
loadRangersSchedule();



async function loadNFLSchedule(){
  try{
    const res = await fetch('/houseboard/daybuddy/nfl/schedule', {cache:'no-store'});
    if(!res.ok) throw new Error('NFL schedule fetch failed');
    const data = await res.json();

    const host = document.getElementById('nfl-sched');
    if(!host) return;

    const games = Array.isArray(data.games) ? data.games : [];
    if(!games.length){
      host.textContent = 'No NFL games in the next 7 days.';
      return;
    }

    // Classify game slot based on local (browser) kickoff time:
    // before 4:00 PM → "morning" (blue)
    // 4:00–7:59 PM   → "afternoon" (yellow)
    // 8:00 PM+       → "evening"  (red)
    function classifySlotFromTimeLabel(timeLabel, fallbackSlot) {
      const mins = parseStartMinutes(timeLabel || '');
      let slot = fallbackSlot || '';

      if (mins != null) {
        if (mins < 16 * 60) {
          slot = 'morning';
        } else if (mins < 20 * 60) {
          slot = 'afternoon';
        } else {
          slot = 'evening';
        }
      }
      return slot;
    }

    // Group games by date string
    const byDate = {};
    for(const g of games){
      const key = g.date || g.date_label || 'unknown';
      if(!byDate[key]) byDate[key] = { meta: g, list: [] };
      byDate[key].list.push(g);
    }

    const days = Object.values(byDate).sort((a, b) => {
      const da = a.meta.date || '';
      const db = b.meta.date || '';
      if (da < db) return -1;
      if (da > db) return 1;
      return 0;
    });

    // Build the 7-day strip
    const parts = [];
    for (const day of days) {
      const meta = day.meta;
      parts.push('<div class="nfl-day">');
      parts.push(
        `<div class="day-label">${
          meta.day_label || meta.weekday_label || ''
        } ${
          meta.date_label || meta.date || meta.iso_date || ''
        }</div>`
      );

      if (!day.list.length) {
        parts.push('<div class="nogame">No game</div>');
      } else {
        // Sort by slot so that "before 4pm" (blue) games come first,
        // 4–7:59pm (yellow) second, and 8pm+ (red) last.
        const ordered = [...day.list].sort((a, b) => {
          const order = { morning: 0, afternoon: 1, evening: 2 };

          const timeA =
            a.time_label || a.kickoff_label || a.time || a.kickoff || '';
          const timeB =
            b.time_label || b.kickoff_label || b.time || b.kickoff || '';

          const slotA = classifySlotFromTimeLabel(timeA, a.slot);
          const slotB = classifySlotFromTimeLabel(timeB, b.slot);

          const sa = order[slotA] ?? 3;
          const sb = order[slotB] ?? 3;

          if (sa !== sb) return sa - sb;
          // As a tie-breaker, keep original relative order if slots match.
          return 0;
        });




        for (const g of ordered) {
          const timeLabel =
            g.time_label || g.kickoff_label || g.time || g.kickoff || '';
          const slotName = classifySlotFromTimeLabel(timeLabel, g.slot);
          const slotClass = slotName ? ` ${slotName}` : '';

          // Try to build a readable matchup string from several possible fields
          const home =
            g.home_team ||
            g.home ||
            g.home_name ||
            g.home_full ||
            g["Home Team"] ||
            '';
          const away =
            g.away_team ||
            g.away ||
            g.away_name ||
            g.away_full ||
            g["Away Team"] ||
            '';
          const teamsField = g.teams || g.matchup || g.game_label || '';
          const titleField =
            g.title || g.label || g.summary || g.name || g.description || '';

          // Prefer explicit opponent/teams/labels from the backend
          let opp = g.opponent || teamsField || titleField;

          if (!opp) {
            if (home && away) {
              const ha = g.home_away || g.side || '';
              if (ha === 'home') {
                // Home game: opponent AT us
                opp = `${away} @ ${home}`;
              } else if (ha === 'away') {
                // Away game: we are AT opponent
                opp = `${home} vs ${away}`;
              } else {
                opp = `${away} at ${home}`;
              }
            } else {
              // Last-resort fallback: show whatever team name we have, otherwise "Game"
              opp = home || away || 'Game';
            }
          }

          // Build a status string with time / extra info when present
          const extraLabel = g.status || g.note || g.channel || '';
          const statusParts = [];
          if (timeLabel) statusParts.push(timeLabel);
          if (extraLabel) statusParts.push(extraLabel);
          const status = statusParts.length ? ` (${statusParts.join(' • ')})` : '';

          // Map broadcast_class → display letter
          const bc = g.broadcast_class || '';
          const tag = (bc === 'local') ? 'L'
                    : (bc === 'prime') ? 'P'
                    : (bc === 'youtube') ? 'Y'     // YouTube TV / streaming
                    : 'O';                          // Other / unknown

          const isNoGame = opp.toLowerCase().includes('no game');

          if (isNoGame) {
            // "No game" rows: no letter prefix
            parts.push(
              `<div class="nogame">${opp}${status}</div>`
            );
          } else {
            // Normal games keep the L / Y / P / O prefix and show matchup text
            parts.push(
              `<div class="game${slotClass}"><b>${tag}</b> ${opp}${status}</div>`
            );
          }
        }
      }

      parts.push('</div>');
    }

    host.innerHTML = `<div id="nfl-grid">${parts.join('')}</div>`;
  }catch(e){
    console.error(e);
    const host = document.getElementById('nfl-sched');
    if(host) host.textContent = 'NFL schedule unavailable';
  }
}

// initial NFL load
loadNFLSchedule();
</script>
<!-- tlehotsky@houseboard:~/houseboard_temps $ curl -s http://127.0.0.1:8787/network
{"wifi_status": "ok", "wifi_detail": "gooberbest (80% quality)", "internet_status": "ok", "internet_detail": "Online (15.6 ms)", "latency_ms": 15.6, "updated_at": "2025-11-27T12:40:08"}tlehotsky@houseboard:~/houseboard_temps $ 
tlehotsky@houseboard:~/houseboard_temps $ 
tlehotsky@houseboard:~/houseboard_temps $ cat /srv/daybuddy/status/network.json
{"wifi_status": "ok", "wifi_detail": "gooberbest (80% quality)", "internet_status": "ok", "internet_detail -->