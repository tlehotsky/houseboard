<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DayBuddy ‚Äì NFL Schedule Editor</title>
    <style>
      body { background:#050711; color:#f5f7ff; font-family:system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin:0; padding:24px; }
      .card { max-width:1100px; margin:0 auto; background:#111522; border-radius:12px; padding:16px 18px 20px; border:1px solid #262d45; box-shadow:0 18px 40px rgba(0,0,0,0.45); }
      h1 { margin:0 0 4px; font-size:22px; }
      .row { margin-bottom:6px; font-size:13px; opacity:.8; }
      .badges { display:flex; gap:8px; margin:8px 0 10px; flex-wrap:wrap; }
      .badge { font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.02); opacity:0.9; }
      .error { color:#ff9c9c; margin-bottom:8px; font-size:14px; }
      .message { color:#9ff7c2; margin-bottom:8px; font-size:14px; }

      .table-wrapper { margin-top:8px; max-height:70vh; overflow:auto; border-radius:10px; border:1px solid #262d45; background:#050814; }
      table { border-collapse:collapse; width:100%; font-size:12px; min-width:720px; }
      thead { position:sticky; top:0; z-index:5; }
      thead th { background:#181c33; position:sticky; top:0; padding:6px 8px; text-align:left; font-weight:600; border-bottom:1px solid #30385a; white-space:nowrap; }
      tbody tr:nth-child(even) { background:#090d1a; }
      tbody tr:nth-child(odd) { background:#050814; }
      td { padding:3px 6px; border-bottom:1px solid #14182b; }
      td:first-child, th:first-child { position:sticky; left:0; background:#151a30; box-shadow:2px 0 0 #14182b; }
      tbody tr:hover { background:#1a2236; }
      tbody tr:hover td:first-child { background:#202944; }

      input.cell-input, select.cell-input { width:100%; box-sizing:border-box; border-radius:4px; border:1px solid rgba(255,255,255,0.08); padding:3px 5px; background:rgba(0,0,0,0.25); color:#f5f7ff; font-size:12px; font-family:inherit; }
      input.cell-input:focus, select.cell-input:focus { outline:none; border-color:#5b8dff; box-shadow:0 0 0 1px rgba(91,141,255,0.7); }

      .actions { margin-top:12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:13px; }
      button { background:#1a2333; color:#f5f7ff; border:1px solid #2a3750; border-radius:999px; padding:7px 16px; font-weight:600; cursor:pointer; }
      button:hover { background:#222d42; }
      a { color:#8fb5ff; text-decoration:none; }
      a:hover { text-decoration:underline; }
      .hint { opacity:0.72; font-size:12px; }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>NFL Schedule CSV Editor</h1>
      <div style="margin:12px 0; padding:12px; background:#0d1222; border:1px solid #2a314a; border-radius:10px;">
        <div style="font-size:14px; font-weight:600; margin-bottom:6px;">Local TV Schedule Links</div>
        <div style="display:flex; flex-direction:row; flex-wrap:wrap; gap:16px; font-size:13px; align-items:center;">
          <a href="https://www.cbsnews.com/newyork/program-guide/" target="_blank" style="color:#8fb5ff;">üì∫ CBS New York</a>
          <a href="https://www.nbcnewyork.com/tv-schedule/" target="_blank" style="color:#8fb5ff;">üì∫ NBC New York</a>
          <a href="https://www.fox5ny.com/whats-on-fox-5" target="_blank" style="color:#8fb5ff;">üì∫ FOX New York</a>
          <a href="https://abc7ny.com/tvlistings/" target="_blank" style="color:#8fb5ff;">üì∫ ABC New York</a>
        </div>
      </div>
      <div class="row">File: {{ csv_path }}</div>
      <div class="badges">
        <div class="badge">Match Number</div>
        <div class="badge">Round Number</div>
        <div class="badge">Date (with time)</div>
        <div class="badge">Location</div>
        <div class="badge">Home / Away Teams</div>
        <div class="badge">Result</div>
        <div class="badge">Broadcast</div>
      </div>

      {% if error %}
        <div class="error">{{ error }}</div>
      {% endif %}
      {% if message %}
        <div class="message">{{ message }}</div>
      {% endif %}

      <form method="post" onsubmit="return syncCsvBeforeSubmit()">
        {% csrf_token %}

        <!-- Hidden raw CSV field that the view reads/writes -->
        <textarea id="csv_raw" name="csv_text" style="display:none;">{{ csv_text|escape }}</textarea>

        <div class="row" style="margin-top:8px; display:flex; gap:8px; align-items:center; font-size:13px;">
          <label for="weekFilter">Filter by Week:</label>
          <select id="weekFilter" style="padding:4px 8px; border-radius:6px; border:1px solid #2a3750; background:#050814; color:#f5f7ff; font-size:13px;">
            <option value="">All weeks</option>
          </select>
        </div>

        <div class="table-wrapper">
          <table id="csvTable">
            <thead></thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="actions">
          <button type="submit">Save CSV</button>
          <a href="/houseboard/daybuddy/week/">‚Üê Back to Week View</a>
          <span class="hint">Dates are displayed in your local time, but saved back to the CSV in UTC.</span>
        </div>
      </form>
    </div>

    <script>
      function parseCsv(text) {
        if (!text) {
          return { headers: [], rows: [] };
        }
        const lines = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n").filter(line => line.trim().length > 0);
        if (lines.length === 0) {
          return { headers: [], rows: [] };
        }
        const headers = lines[0].split(",");
        const rows = lines.slice(1).map(line => line.split(","));
        return { headers, rows };
      }

      function buildTableFromCsv() {
        const rawEl = document.getElementById("csv_raw");
        const table = document.getElementById("csvTable");
        if (!rawEl || !table) return;

        const thead = table.querySelector("thead");
        const tbody = table.querySelector("tbody");
        thead.innerHTML = "";
        tbody.innerHTML = "";

        const data = parseCsv(rawEl.value);
        const headers = data.headers;
        const rows = data.rows;

        if (headers.length === 0) {
          return;
        }

        const headRow = document.createElement("tr");
        headers.forEach(h => {
          const th = document.createElement("th");
          const name = h.trim();
          th.setAttribute("data-original-header", name);
          th.textContent = (name.toLowerCase() === "round number") ? "Week Number" : name;
          headRow.appendChild(th);
        });
        thead.appendChild(headRow);

        const weekFilter = document.getElementById("weekFilter");
        const weekSet = new Set();
        const roundIdx = headers.findIndex(h => h.trim().toLowerCase() === "round number");

        rows.forEach((row, rowIdx) => {
          const tr = document.createElement("tr");

          let weekVal = "";
          if (roundIdx >= 0) {
            weekVal = (row[roundIdx] || "").trim();
            if (weekVal) {
              weekSet.add(weekVal);
              tr.setAttribute("data-week", weekVal);
            }
          }


          headers.forEach((_, colIdx) => {
            const td = document.createElement("td");
            if (headers[colIdx].trim().toLowerCase() === "broadcast") {
              const select = document.createElement("select");
              select.className = "cell-input";
              select.setAttribute("data-row", rowIdx);
              select.setAttribute("data-col", colIdx);

              const options = ["CBS", "NBC", "FOX", "ABC", "ESPN", "YouTube", "Prime", "Other", ""];
              options.forEach(opt => {
                const o = document.createElement("option");
                o.value = opt;
                o.textContent = opt === "" ? "(blank)" : opt;
                if ((row[colIdx] || "").trim().toLowerCase() === opt.toLowerCase()) {
                  o.selected = true;
                }
                select.appendChild(o);
              });

              td.appendChild(select);
            } else {
              const input = document.createElement("input");
              input.type = "text";
              input.className = "cell-input";
              input.setAttribute("data-row", rowIdx);
              input.setAttribute("data-col", colIdx);

              const originalValue = (row[colIdx] || "").trim();

              // If this is the Date column, display local time but keep CSV value in UTC.
              if (detectDateColumn(headers[colIdx])) {
                const fmt = inferDateFormatStyle(originalValue);
                input.dataset.dateStyle = fmt.style;
                input.dataset.dateHasSeconds = fmt.hasSeconds ? "1" : "0";

                // Always preserve the original UTC CSV value unless the user edits it.
                input.dataset.csvValue = originalValue;

                const utcDate = parseUtcDate(originalValue);
                if (utcDate) {
                  input.value = formatLocalForDisplay(utcDate, fmt.style, fmt.hasSeconds);
                } else {
                  // If we can‚Äôt parse, fall back to showing raw value.
                  input.value = originalValue;
                }

                // When user edits the displayed local time, convert back to UTC for saving.
                input.addEventListener("change", function () {
                  const localDate = parseLocalInputToUtcDate(input.value);
                  if (!localDate) {
                    // If parsing fails, save whatever the user typed.
                    input.dataset.csvValue = input.value;
                    return;
                  }
                  const style = input.dataset.dateStyle || "iso";
                  const hasSeconds = input.dataset.dateHasSeconds === "1";
                  input.dataset.csvValue = formatUtcForCsv(localDate, style, hasSeconds);
                });
              } else {
                input.value = originalValue;
              }

              td.appendChild(input);
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        // Populate the week filter dropdown
        if (weekFilter) {
          const currentValue = weekFilter.value;
          weekFilter.innerHTML = "";
          const optAll = document.createElement("option");
          optAll.value = "";
          optAll.textContent = "All weeks";
          weekFilter.appendChild(optAll);

          Array.from(weekSet)
            .sort((a, b) => {
              const na = parseInt(a, 10);
              const nb = parseInt(b, 10);
              if (!isNaN(na) && !isNaN(nb)) return na - nb;
              return String(a).localeCompare(String(b));
            })
            .forEach(week => {
              const o = document.createElement("option");
              o.value = week;
              o.textContent = "Week " + week;
              weekFilter.appendChild(o);
            });

          if (currentValue && Array.from(weekFilter.options).some(o => o.value === currentValue)) {
            weekFilter.value = currentValue;
          } else {
            weekFilter.value = "";
          }
        }

        // Apply current filter (if any)
        filterRowsByWeek();
      }

      function filterRowsByWeek() {
        const table = document.getElementById("csvTable");
        const weekFilter = document.getElementById("weekFilter");
        if (!table || !weekFilter) return;

        const value = weekFilter.value.trim();
        const rows = Array.from(table.querySelectorAll("tbody tr"));

        rows.forEach(tr => {
          const weekVal = (tr.getAttribute("data-week") || "").trim();
          if (!value || !weekVal) {
            tr.style.display = "";
          } else {
            tr.style.display = (weekVal === value) ? "" : "none";
          }
        });
      }

      function pad2(n) {
        return String(n).padStart(2, "0");
      }

      function detectDateColumn(header) {
        const h = (header || "").trim().toLowerCase();
        // Matches your CSV badge ‚ÄúDate (with time)‚Äù but also supports simple ‚ÄúDate‚Äù
        return h === "date" || h === "date (with time)" || h.includes("date");
      }

      function parseUtcDate(value) {
        const s = (value || "").trim();
        if (!s) return null;

        // 1) Let the browser parse ISO strings (including Z/offset)
        let d = new Date(s);
        if (!isNaN(d.getTime())) return d;

        // 2) Handle common non-ISO UTC formats like "YYYY-MM-DD HH:MM" or "YYYY-MM-DD HH:MM:SS"
        // Treat as UTC by converting to ISO and appending Z.
        const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (m) {
          const yyyy = m[1], mm = m[2], dd = m[3], HH = m[4], MI = m[5], SS = m[6] || "00";
          d = new Date(`${yyyy}-${mm}-${dd}T${HH}:${MI}:${SS}Z`);
          if (!isNaN(d.getTime())) return d;
        }

        // 3) Handle EU-style format like "DD/MM/YYYY HH:MM" or "DD/MM/YYYY HH:MM:SS" as UTC
        const m2 = s.match(/^(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (m2) {
          const dd = m2[1], mm = m2[2], yyyy = m2[3], HH = m2[4], MI = m2[5], SS = m2[6] || "00";
          d = new Date(`${yyyy}-${mm}-${dd}T${HH}:${MI}:${SS}Z`);
          if (!isNaN(d.getTime())) return d;
        }

        return null;
      }

      function formatLocalForDisplay(dateObj, formatStyle, hasSeconds) {
        // Display in the user‚Äôs local timezone, but keep the CSV's date ordering.
        const y = dateObj.getFullYear();
        const m = pad2(dateObj.getMonth() + 1);
        const d = pad2(dateObj.getDate());
        const mi = pad2(dateObj.getMinutes());
        const ss = pad2(dateObj.getSeconds());

        // 12-hour time with AM/PM (no leading zero on hour)
        const hour24 = dateObj.getHours();
        const ampm = hour24 >= 12 ? "PM" : "AM";
        let hour12 = hour24 % 12;
        if (hour12 === 0) hour12 = 12;
        const time = hasSeconds ? `${hour12}:${mi}:${ss} ${ampm}` : `${hour12}:${mi} ${ampm}`;

        if (formatStyle === "dmy_slash") {
          // DD/MM/YYYY
          return `${d}/${m}/${y} ${time}`;
        }

        // Default: YYYY-MM-DD
        return `${y}-${m}-${d} ${time}`;
      }

      function formatUtcForCsv(dateObj, formatStyle, hasSeconds) {
        // Keep output format close to what was originally in the CSV
        const y = dateObj.getUTCFullYear();
        const m = pad2(dateObj.getUTCMonth() + 1);
        const d = pad2(dateObj.getUTCDate());
        const hh = pad2(dateObj.getUTCHours());
        const mi = pad2(dateObj.getUTCMinutes());
        const ss = pad2(dateObj.getUTCSeconds());

        if (formatStyle === "dmy_slash") {
          // DD/MM/YYYY
          return hasSeconds ? `${d}/${m}/${y} ${hh}:${mi}:${ss}` : `${d}/${m}/${y} ${hh}:${mi}`;
        }

        if (formatStyle === "space") {
          return hasSeconds ? `${y}-${m}-${d} ${hh}:${mi}:${ss}` : `${y}-${m}-${d} ${hh}:${mi}`;
        }

        // default: ISO
        const base = hasSeconds ? `${y}-${m}-${d}T${hh}:${mi}:${ss}Z` : `${y}-${m}-${d}T${hh}:${mi}:00Z`;
        return base;
      }

      function inferDateFormatStyle(original) {
        const s = (original || "").trim();
        const hasSeconds = /:(\d{2})\s*$/.test(s) || /:(\d{2})Z\s*$/.test(s) || /T\d{2}:\d{2}:\d{2}/.test(s);

        // Preserve common CSV formats:
        // - dmy_slash: DD/MM/YYYY HH:MM[:SS]
        // - iso: ISO-ish strings with T/Z/offset
        // - space: YYYY-MM-DD HH:MM[:SS]
        let style = "space";
        if (/^\d{2}\/\d{2}\/\d{4}/.test(s)) {
          style = "dmy_slash";
        } else if (s.includes("T") || s.toLowerCase().includes("z") || /[+-]\d{2}:?\d{2}$/.test(s)) {
          style = "iso";
        } else {
          style = "space";
        }

        return { style, hasSeconds };
      }

      function parseLocalInputToUtcDate(value) {
        const s = (value || "").trim();
        if (!s) return null;

        // Accept local input like "YYYY-MM-DD HH:MM" or "YYYY-MM-DD HH:MM:SS" or ISO without Z
        let d = new Date(s);
        if (!isNaN(d.getTime())) return d;

        const m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (m) {
          const yyyy = parseInt(m[1], 10);
          const mm = parseInt(m[2], 10) - 1;
          const dd = parseInt(m[3], 10);
          const HH = parseInt(m[4], 10);
          const MI = parseInt(m[5], 10);
          const SS = parseInt(m[6] || "0", 10);
          // Construct as LOCAL time
          d = new Date(yyyy, mm, dd, HH, MI, SS);
          if (!isNaN(d.getTime())) return d;
        }

        // Accept local input in YYYY-MM-DD H:MM[:SS] AM/PM
        const mAmPm = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{1,2}):(\d{2})(?::(\d{2}))?\s*([AaPp][Mm])$/);
        if (mAmPm) {
          const yyyy = parseInt(mAmPm[1], 10);
          const mm = parseInt(mAmPm[2], 10) - 1;
          const dd = parseInt(mAmPm[3], 10);
          let HH = parseInt(mAmPm[4], 10);
          const MI = parseInt(mAmPm[5], 10);
          const SS = parseInt(mAmPm[6] || "0", 10);
          const ampm = String(mAmPm[7]).toUpperCase();
          if (ampm === "PM" && HH < 12) HH += 12;
          if (ampm === "AM" && HH === 12) HH = 0;
          d = new Date(yyyy, mm, dd, HH, MI, SS);
          if (!isNaN(d.getTime())) return d;
        }

        // Also accept local input in DD/MM/YYYY HH:MM[:SS]
        const m2 = s.match(/^(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (m2) {
          const dd = parseInt(m2[1], 10);
          const mm = parseInt(m2[2], 10) - 1;
          const yyyy = parseInt(m2[3], 10);
          const HH = parseInt(m2[4], 10);
          const MI = parseInt(m2[5], 10);
          const SS = parseInt(m2[6] || "0", 10);
          d = new Date(yyyy, mm, dd, HH, MI, SS);
          if (!isNaN(d.getTime())) return d;
        }

        // Accept local input in DD/MM/YYYY H:MM[:SS] AM/PM
        const m2AmPm = s.match(/^(\d{2})\/(\d{2})\/(\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*([AaPp][Mm])$/);
        if (m2AmPm) {
          const dd = parseInt(m2AmPm[1], 10);
          const mm = parseInt(m2AmPm[2], 10) - 1;
          const yyyy = parseInt(m2AmPm[3], 10);
          let HH = parseInt(m2AmPm[4], 10);
          const MI = parseInt(m2AmPm[5], 10);
          const SS = parseInt(m2AmPm[6] || "0", 10);
          const ampm = String(m2AmPm[7]).toUpperCase();
          if (ampm === "PM" && HH < 12) HH += 12;
          if (ampm === "AM" && HH === 12) HH = 0;
          d = new Date(yyyy, mm, dd, HH, MI, SS);
          if (!isNaN(d.getTime())) return d;
        }

        return null;
      }

      function csvEscape(value) {
        if (value === null || value === undefined) return "";
        const needsQuotes = /[",\n]/.test(value);
        let v = String(value).replace(/"/g, '""');
        return needsQuotes ? '"' + v + '"' : v;
      }

      function syncCsvBeforeSubmit() {
        const table = document.getElementById("csvTable");
        const rawEl = document.getElementById("csv_raw");
        if (!table || !rawEl) return true; // let submit continue

        const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.getAttribute("data-original-header") || th.textContent.trim());
        const rows = [];
        const trList = Array.from(table.querySelectorAll("tbody tr"));

        trList.forEach(tr => {
          const cells = [];
          const cellsElems = Array.from(tr.querySelectorAll(".cell-input"));
          cellsElems.forEach(elem => {
            const v = (elem.dataset && typeof elem.dataset.csvValue !== "undefined") ? elem.dataset.csvValue : (elem.value || "");
            cells.push(csvEscape(v));
          });
          rows.push(cells.join(","));
        });

        const headerLine = headers.join(",");
        rawEl.value = [headerLine].concat(rows).join("\n");
        try {
          const wrapper = document.querySelector(".table-wrapper");
          if (wrapper && window.sessionStorage) {
            // Save scroll position
            sessionStorage.setItem("nfl_edit_scroll", String(wrapper.scrollTop));

            // Save the row index the user was working on (if any)
            const active = document.activeElement;
            let rowIndexToSave = null;
            if (active && active.classList && active.classList.contains("cell-input")) {
              rowIndexToSave = active.getAttribute("data-row");
            } else {
              // Fallback: first visible row in the viewport
              const rows = Array.from(wrapper.querySelectorAll("tbody tr"));
              for (const r of rows) {
                const rect = r.getBoundingClientRect();
                const wrapperRect = wrapper.getBoundingClientRect();
                if (rect.bottom > wrapperRect.top) {
                  const firstCellInput = r.querySelector(".cell-input");
                  if (firstCellInput) {
                    rowIndexToSave = firstCellInput.getAttribute("data-row");
                  }
                  break;
                }
              }
            }
            if (rowIndexToSave !== null) {
              sessionStorage.setItem("nfl_edit_row_index", String(rowIndexToSave));
            }
          }
        } catch (e) {
          // ignore scroll persistence errors
        }
        return true; // allow the form submit
      }

      document.addEventListener("DOMContentLoaded", function () {
        buildTableFromCsv();
        const weekFilter = document.getElementById("weekFilter");
        if (weekFilter) {
          weekFilter.addEventListener("change", filterRowsByWeek);
        }
        try {
          const wrapper = document.querySelector(".table-wrapper");
          if (wrapper && window.sessionStorage) {
            const savedRow = sessionStorage.getItem("nfl_edit_row_index");
            if (savedRow !== null) {
              const targetInput = wrapper.querySelector('.cell-input[data-row="' + savedRow + '"]');
              if (targetInput && targetInput.scrollIntoView) {
                targetInput.scrollIntoView({ block: "center" });
                targetInput.focus();
                return; // we've restored position based on row
              }
            }

            const savedScroll = sessionStorage.getItem("nfl_edit_scroll");
            if (savedScroll !== null) {
              const offset = parseInt(savedScroll, 10);
              if (!isNaN(offset)) {
                wrapper.scrollTop = offset;
              }
            }
          }
        } catch (e) {
          // ignore scroll persistence errors
        }
      });
    </script>
  </body>
</html>
